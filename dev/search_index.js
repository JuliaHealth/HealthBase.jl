var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Base.show-Tuple{IO, HealthTable}","page":"API","title":"Base.show","text":"Base.show(io::IO, ht::HealthTable)\n\nPretty-print a HealthTable to any IO stream (REPL, file, etc.).\n\nIf the underlying table is empty, prints a friendly message.\nOtherwise prints the full table using PrettyTables.jl with left-aligned columns.\nDisplays the OMOP-CDM version (from metadata) beneath the table when available.\n\nThis method is purely for display; it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"OMOPCDMWorkflow/#OMOP-CDM-Workflow-with-HealthTable","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow with HealthTable","text":"","category":"section"},{"location":"OMOPCDMWorkflow/#Typical-Workflow","page":"OMOP CDM Workflow","title":"Typical Workflow","text":"","category":"section"},{"location":"OMOPCDMWorkflow/","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow","text":"The envisioned process for working with OMOP CDM data using the HealthBase.jl components typically follows these steps:","category":"page"},{"location":"OMOPCDMWorkflow/","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow","text":"Data Loading   Raw data is loaded into a suitable tabular structure, most commonly a DataFrame.\nValidation and Wrapping with HealthTable   The raw DataFrame is then wrapped using HealthBase.HealthTable. This function takes the DataFrame and uses the attached OMOP CDM version (e.g., \"v5.4.1\") to validate its structure and column types against the OMOP CDM schema.\nIt checks if the column types are compatible with the expected OMOP CDM types (from OMOPCommonDataModel.jl).\nIf disable_type_enforcement = false, it will throw errors on mismatches or attempt safe conversions.\nIt attaches metadata to columns indicating their OMOP CDM types.\nThe result is a HealthTable instance that wraps the validated DataFrame and exposes the Tables.jl interface.\nInteracting via Tables.jl   Once wrapped, the HealthTable instance can be seamlessly used with any Tables.jl-compatible tools and standard Tables.jl functions.\nApplying Preprocessing Utilities   After wrapping, you can apply preprocessing steps essential for analysis or modeling. These include:\nOne-hot encoding\nHandling of high-cardinality categorical variables\nConcept mapping utilities\nThese utilities usually return a modified HealthTable or a materialized DataFrame ready for downstream use.","category":"page"},{"location":"OMOPCDMWorkflow/#Example-Usage","page":"OMOP CDM Workflow","title":"Example Usage","text":"","category":"section"},{"location":"OMOPCDMWorkflow/","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow","text":"using DataFrames, OMOPCommonDataModel, InlineStrings, Serialization, Dates, FeatureTransforms, DBInterface, DuckDB\nusing HealthBase\n\n# Assume 'condition_occurrence_df' is a DataFrame loaded from a CSV/database\ncondition_occurrence_df = DataFrame(\n    condition_occurrence_id = [1, 2, 3],\n    person_id = [101, 102, 101],\n    condition_concept_id = [201826, 433736, 317009],\n    condition_start_date = [Date(2010,1,1), Date(2012,5,10), Date(2011,3,15)]\n    # ... other fields\n)\n\n# Validate and wrap the DataFrame with HealthTable\nht_conditions = HealthTable(condition_occurrence_df; omop_cdm_version=\"v5.4.1\")\n\n# 1. Schema Inspection\nsch = Tables.schema(ht_conditions)\nprintln(\"Schema Names: \", sch.names)\nprintln(\"Schema Types: \", sch.types)\n# This should output the names and types from the validated DataFrame\n\n# 2. Iteration (Rows)\nfor row in Tables.rows(ht_conditions)\n    # 'row' is a Tables.Row, with fields matching the OMOP schema\n    println(\"Person ID: $(row.person_id), Condition: $(row.condition_concept_id)\")\nend\n\n# 3. Integration with other packages (example: MLJ.jl)\n# 4. Materialization\n# DataFrame(ht_conditions)","category":"page"},{"location":"OMOPCDMWorkflow/#Preprocessing-and-Utilities","page":"OMOP CDM Workflow","title":"Preprocessing and Utilities","text":"","category":"section"},{"location":"OMOPCDMWorkflow/","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow","text":"Preprocessing utilities can operate on HealthTable objects (or their materialized versions), leveraging the Tables.jl interface and schema awareness derived via Tables.schema.","category":"page"},{"location":"OMOPCDMWorkflow/","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow","text":"Examples include:","category":"page"},{"location":"OMOPCDMWorkflow/","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow","text":"one_hot_encode(ht::HealthTable, column_symbol::Symbol; drop_original=true)\napply_vocabulary_compression(ht::HealthTable, column_symbol::Symbol, mapping_dict::Dict)\nmap_concepts(ht::HealthTable, column_symbol::Symbol, concept_map::AbstractDict)\nmap_concepts!(ht::HealthTable, column_symbol::Symbol, concept_map::AbstractDict) (in-place version)","category":"page"},{"location":"OMOPCDMWorkflow/","page":"OMOP CDM Workflow","title":"OMOP CDM Workflow","text":"These functions follow the principle of user-triggered, optional transformations configurable via keyword arguments.","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Welcome to the Quickstart guide for HealthBase.jl!   This guide walks you through setting up your Julia environment, creating example OMOP CDM data, validating it, and applying preprocessing steps using the HealthTable system.","category":"page"},{"location":"quickstart/#Getting-Started","page":"Quickstart","title":"Getting Started","text":"","category":"section"},{"location":"quickstart/#Launch-Julia-and-Enter-Your-Project-Environment","page":"Quickstart","title":"Launch Julia and Enter Your Project Environment","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To get started:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Open your terminal or Julia REPL.\nNavigate to your project folder (where Project.toml is located):","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"cd path/to/your/project","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Activate the project:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"julia --project=.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Optional for docs) For working on documentation:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"julia --project=docs","category":"page"},{"location":"quickstart/#1.-Load-Packages","page":"Quickstart","title":"1. Load Packages","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Before loading HealthBase, you must first load some trigger packages.   These packages enable HealthBase's extensions, which power important features like type validation and concept mapping.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"âš ï¸ Important: Load the following packages before using HealthBase.   Otherwise, some functions may not be available due to missing extensions.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# First, load the trigger packages\nusing DataFrames, OMOPCommonDataModel, InlineStrings, Serialization, Dates, FeatureTransforms, DBInterface, DuckDB\n\n# Then, load HealthBase\nusing HealthBase","category":"page"},{"location":"quickstart/#2.-Create-Example-DataFrames","page":"Quickstart","title":"2. Create Example DataFrames","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We'll create two DataFrames:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"good_df - a minimal, valid slice of the OMOP person table.\nwrong_df - intentionally invalid (wrong types & extra column) so you can see the constructorâ€™s validation in action.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"good_df = DataFrame(\n    person_id = 1:6,\n    gender_concept_id = [8507, 8507, 8532, 8532, 8507, 8532],\n    year_of_birth = [1980, 1995, 1990, 1975, 1988, 2001],\n    race_concept_id = [8527, 8515, 8527, 8516, 8527, 8516]\n)\n\n# Invalid DataFrame to test validation\nwrong_df = DataFrame(\n    person_id = [\"1\", \"2\"],            # Should be Int64\n    gender_concept_id = [8507, 8532],\n    year_of_birth = [1990, 1985],\n    race_concept_id = [8527, 8516],\n    extra_col = [true, false],         # Extra column not in the OMOP schema\n)\n\nht = HealthTable(good_df; omop_cdm_version=\"v5.4.1\")\n\n# OMOP CDM version metadata\nmetadata(ht.source, \"omop_cdm_version\")\n\n# Will give column-specific metadata\ncolmetadata(ht.source, :gender_concept_id)\n\n# This will throw an error (strict enforcement)\nht = HealthTable(wrong_df; omop_cdm_version=\"v5.4.1\", disable_type_enforcement = false)\n\n# If you want to *load anyway* and just receive warnings, disable type enforcement:\nht_relaxed = HealthTable(wrong_df; omop_cdm_version=\"v5.4.1\", disable_type_enforcement = true)","category":"page"},{"location":"quickstart/#3.-Preprocessing-Pipeline","page":"Quickstart","title":"3. Preprocessing Pipeline","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now, we'll apply a series of transformations to clean and prepare the data.","category":"page"},{"location":"quickstart/#Mapping-Concepts","page":"Quickstart","title":"Mapping Concepts","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Convert concept codes (e.g., gender ID) into readable or binary columns using a DuckDB connection.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"conn = DBInterface.connect(DuckDB.DB, \"synthea_1M_3YR.duckdb\")\n\n# Single column, auto-suffixed column name (gender_concept_id_mapped)\nht_mapped = map_concepts(ht, :gender_concept_id, conn; schema = \"dbt_synthea_dev\")\n\n# Multiple columns, custom new column names\nht_mapped2 = map_concepts(ht, [:gender_concept_id, :race_concept_id], conn; new_cols = [\"gender\", \"race\"], schema = \"dbt_synthea_dev\", drop_original=true)\n\n# In-place variant\nmap_concepts!(ht, [:gender_concept_id], conn; schema = \"dbt_synthea_dev\")","category":"page"},{"location":"quickstart/#Manual-Concept-Mapping-(Without-DB)","page":"Quickstart","title":"Manual Concept Mapping (Without DB)","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Sometimes, you may want to map concept IDs using a custom dictionary instead of querying the database.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# Define custom mapping manually\ncustom_map = Dict(8507 => \"Male\", 8532 => \"Female\")\n\n# Option 1: Add a new column using `Base.map`\nht.source.gender_label = map(x -> get(custom_map, x, \"Unknown\"), ht.source.gender_concept_id)\n\n# Option 2: Use `Base.map!` with a new destination vector\ngender_labels = Vector{String}(undef, length(ht.source.gender_concept_id))\nmap!(x -> get(custom_map, x, \"Unknown\"), gender_labels, ht.source.gender_concept_id)\nht.source.gender_label = gender_labels","category":"page"},{"location":"quickstart/#Compress-sparse-categories","page":"Quickstart","title":"Compress sparse categories","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Group rare values into an \"Other\" category so they donâ€™t overwhelm your model.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"ht_compressed = apply_vocabulary_compression(ht_mapped; cols = [:race_concept_id], min_freq = 2, other_label = \"Other\")","category":"page"},{"location":"quickstart/#One-hot-encode-categorical-columns","page":"Quickstart","title":"One-hot encode categorical columns","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Convert categorical codes into binary indicator columns (true/false).","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"ht_ohe = one_hot_encode(ht_compressed; cols=[:gender_concept_id, :race_concept_id])","category":"page"},{"location":"quickstart/#For-Developers:-Interactive-Use-in-the-REPL","page":"Quickstart","title":"For Developers: Interactive Use in the REPL","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"When working interactively in the REPL during development:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Always load the trigger packages first\nThen load HealthBase\nOnly after that, use extension functions like one_hot_encode, map_concepts, etc.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# Correct load order for extensions to work:\nusing DataFrames, OMOPCommonDataModel, InlineStrings, Serialization, Dates, FeatureTransforms, DBInterface, DuckDB\nusing HealthBase\n\n# Now this will work:\n# ht_ohe = one_hot_encode(ht; cols=[:gender_concept_id])","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Happy experimenting with HealthBase.jl! ðŸŽ‰   Feel free to explore more advanced workflows in the other guide sections.","category":"page"},{"location":"observational_template_workflow/#Observational-Health-Study","page":"Observational Template Workflow","title":"Observational Health Study","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"This workflow guide demonstrates how to initialize and run an observational health study using HealthBase.jl.\nBy the end of this tutorial, you will be able to:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Initialize a new observational health study project using HealthBase.jl\nDownload phenotype definitions and concept sets from OHDSI ATLAS via WebAPI\nTranslate OHDSI cohort definitions to SQL using OHDSICohortExpressions.jl\nExecute translated SQL against an OMOP CDM v5.4 database using FunSQL.jl","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"","category":"page"},{"location":"observational_template_workflow/#1.-Setup-and-Study-Initialization","page":"Observational Template Workflow","title":"1. Setup and Study Initialization","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"First, ensure that the required packages are installed in your global Julia environment:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"import Pkg\nPkg.add(\n  [\n    \"DrWatson\",\n    \"HealthBase\"\n  ]\n)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Note: The global environment is the default Julia package environment shared across projects. To learn more about environments, see the Pkg documentation.","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Then, load the packages:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"using DrWatson\nusing HealthBase\n\nimport HealthBase:\n  cohortsdir","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Initialize a new observational health study:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"julia> initialize_study(\"sample_study\", \"Jenna Reps\"; template = :observational)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"This command creates a new directory called sample_study using the :observational template. Then, it activates a new Julia environment named sample_study.","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"After initializing the study directory and Julia environment, install the remaining required packages:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Pkg.add(\n  [\n    \"DataFrames\",\n    \"Downloads\",\n    \"DBInterface\",\n    \"DuckDB\",\n    \"FunSQL\",\n    \"OHDSIAPI\",\n    \"OHDSICohortExpressions\"\n  ]\n)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Now, load and import all necessary packages and functions:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"using DataFrames\nusing Downloads\n\nimport DBInterface:\n  connect,\n  execute\nimport DuckDB:\n  DB\nimport FunSQL:\n  reflect,\n  render\nimport OHDSIAPI:\n  download_cohort_definition,\n  download_concept_set\nimport OHDSICohortExpressions:\n  translate","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"","category":"page"},{"location":"observational_template_workflow/#2.-Download-OHDSI-Cohort-Definitions","page":"Observational Template Workflow","title":"2. Download OHDSI Cohort Definitions","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"OHDSIAPI.jl is a Julia interface to various OHDSI WebAPI services. We can use it to access OHDSI ATLAS, OHDSI's web-based tool for defining phenotypes and analyses.","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Here, we can download a single cohort definition using its ATLAS ID:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"cohort_path = download_cohort_definition(1793014; output_dir=cohortsdir())","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Tip: To download multiple cohort definitions with more verbose output:cohort_ids = [1793014, 1792956]\ndownload_cohort_definition(cohort_ids; progress_bar=true, verbose=true)You can also download associated concept sets:download_concept_set(cohort_ids; deflate=true, output_dir=cohortsdir())","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"","category":"page"},{"location":"observational_template_workflow/#3.-Translate-Cohort-Definitions-to-SQL","page":"Observational Template Workflow","title":"3. Translate Cohort Definitions to SQL","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Now, we can use OHDSICohortExpressions.jl to convert this cohort definition into SQL.","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"cohort_expression = cohortsdir(\"1793014.json\")\n\nfun_sql = translate(\n    cohort_expression;\n    cohort_definition_id = 1\n)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"","category":"page"},{"location":"observational_template_workflow/#4.-Download-Synthetic-Database","page":"Observational Template Workflow","title":"4. Download Synthetic Database","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"For this guide, we will use a synthetic OMOP CDM v5.3 database from Eunomia. We will download it as follows:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"# TODO: Add download URL\nurl = \"\"\ndb_path = datadir(\"exp_raw\", \"omop_cdm.db\")\nDownloads.download(url, db_path)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"","category":"page"},{"location":"observational_template_workflow/#5.-Execute-the-Cohort-on-a-Database","page":"Observational Template Workflow","title":"5. Execute the Cohort on a Database","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Create database connection and configure dialect:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"const CONNECTION = connect(DB, datadir(\"exp_raw\", \"omop_cdm.db\"))\nconst SCHEMA = \"\"\nconst DIALECT = :postgresql","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Reflect database catalog and render SQL:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"catalog = reflect(CONNECTION; schema=SCHEMA, dialect=DIALECT)\nsql = render(catalog, fun_sql)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Execute cohort query and insert results into cohort table:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"execute(\n  CONNECTION,\n  \"\"\"\n  INSERT INTO cohort\n  SELECT * FROM ($sql) AS foo;\n  \"\"\"\n)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Query results into a DataFrame:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"df = execute(CONNECTION, \"SELECT COUNT(*) FROM cohort;\") |> DataFrame","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Display DataFrame:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"println(df)","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"","category":"page"},{"location":"observational_template_workflow/#Summary","page":"Observational Template Workflow","title":"Summary","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"This workflow demonstrates how to run an observational health study using tools from the JuliaHealth ecosystem:","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"Initialize a project with a standardized structure using HealthBase.jl\nDownload cohort and concept set definitions from OHDSI ATLAS using OHDSIAPI.jl\nConvert JSON cohort logic to SQL using OHDSICohortExpressions.jl\nExecute SQL queries on an OMOP CDM v5.4 database using FunSQL.jl and DuckDB","category":"page"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"","category":"page"},{"location":"observational_template_workflow/#Related-Resources","page":"Observational Template Workflow","title":"Related Resources","text":"","category":"section"},{"location":"observational_template_workflow/","page":"Observational Template Workflow","title":"Observational Template Workflow","text":"OHDSI Common Data Model\nATLAS Tool (Demo)\nDrWatson.jl Documentation\nHealthBase.jl GitHub\nJuliaHealth GitHub","category":"page"},{"location":"HealthTableOMOPCDM/#OMOP-CDM-Support-for-HealthTable","page":"HealthTable: OMOP CDM Support","title":"OMOP CDM Support for HealthTable","text":"","category":"section"},{"location":"HealthTableOMOPCDM/#Core-Goals-and-Features","page":"HealthTable: OMOP CDM Support","title":"Core Goals & Features","text":"","category":"section"},{"location":"HealthTableOMOPCDM/","page":"HealthTable: OMOP CDM Support","title":"HealthTable: OMOP CDM Support","text":"The HealthTable interface in HealthBase.jl is designed to make working with OMOP CDM data in Julia easy, robust, and compatible with the Tables.jl ecosystem. The key features include:","category":"page"},{"location":"HealthTableOMOPCDM/","page":"HealthTable: OMOP CDM Support","title":"HealthTable: OMOP CDM Support","text":"Schema-Aware Validation: Instead of just wrapping your data, HealthTable actively validates it against the official OMOP CDM specification using OMOPCommonDataModel.jl. This includes:\nColumn Type Enforcement: Verifies that column types in the input DataFrame match the official OMOP schema (e.g., person_id is Int64, condition_start_date is Date).\nClear Error Reporting: If mismatches exist, the constructor returns detailed messages about all invalid columns or can emit warnings if type enforcement is disabled.\nMetadata Attachment: Attaches OMOP metadata (like cdmDatatype, standardConcept, etc.) directly to each validated column.\nPreprocessing Utilities: Built-in tools for data preparation include:\none_hot_encode: One-hot encodes categorical variables using FeatureTransforms.jl.\napply_vocabulary_compression: Groups rare categorical values under a shared \"Other\" label.\nmap_concepts: Maps concept IDs to human-readable concept names using a DuckDB-backed concept table.\nmap_concepts!: An in-place variant of concept mapping that modifies the existing table.\nTables.jl Compatibility: The HealthTable type implements the full Tables.jl interface so it can be used with any downstream package in the Julia data ecosystem.\nJuliaHealth Integration: Designed to interoperate seamlessly with current and future JuliaHealth tools and projects.\nExtensible Foundation: The core architecture is extensible future support could include streaming, direct DuckDB views, or remote OMOP datasets.","category":"page"},{"location":"HealthTableOMOPCDM/#Tables.jl-Interface-Sketch","page":"HealthTable: OMOP CDM Support","title":"Tables.jl Interface Sketch","text":"","category":"section"},{"location":"HealthTableOMOPCDM/","page":"HealthTable: OMOP CDM Support","title":"HealthTable: OMOP CDM Support","text":"The HealthTable type is the main interface for working with OMOP CDM tables. You construct it by passing in a DataFrame and optionally specifying a CDM version. The constructor will validate the schema and attach metadata. The resulting object:","category":"page"},{"location":"HealthTableOMOPCDM/","page":"HealthTable: OMOP CDM Support","title":"HealthTable: OMOP CDM Support","text":"Is a wrapper over the validated DataFrame (ht.source),\nProvides schema-aware access to data,\nCan be used anywhere a Tables.jl-compatible table is expected.","category":"page"},{"location":"HealthTableOMOPCDM/","page":"HealthTable: OMOP CDM Support","title":"HealthTable: OMOP CDM Support","text":"This eliminates the need for a separate wrapping step the constructor itself ensures conformance and returns a ready-to-use tabular object.","category":"page"},{"location":"HealthTableOMOPCDM/","page":"HealthTable: OMOP CDM Support","title":"HealthTable: OMOP CDM Support","text":"In future extensions, similar wrappers could be created for other data sources, such as database queries or streaming sources. These types would implement the same Tables.jl interface to support composable workflows.","category":"page"},{"location":"HealthTablePreprocessing/#HealthTable:-Preprocessing-Functions","page":"HealthTable: Preprocessing Functions","title":"HealthTable: Preprocessing Functions","text":"","category":"section"},{"location":"HealthTablePreprocessing/","page":"HealthTable: Preprocessing Functions","title":"HealthTable: Preprocessing Functions","text":"This page documents the preprocessing and transformation functions available for HealthTable objects when working with OMOP CDM data. These functions are provided by the OMOP CDM extension and enable data preparation workflows for machine learning and analysis.","category":"page"},{"location":"HealthTablePreprocessing/#One-Hot-Encoding","page":"HealthTable: Preprocessing Functions","title":"One-Hot Encoding","text":"","category":"section"},{"location":"HealthTablePreprocessing/","page":"HealthTable: Preprocessing Functions","title":"HealthTable: Preprocessing Functions","text":"Transform categorical variables into binary indicator columns suitable for machine learning algorithms.","category":"page"},{"location":"HealthTablePreprocessing/#HealthBase.one_hot_encode","page":"HealthTable: Preprocessing Functions","title":"HealthBase.one_hot_encode","text":"one_hot_encode(ht::HealthTable; cols, drop_original=true, return_features_only=false)\n\nOne-hot encode the categorical columns in ht using FeatureTransforms.jl.\n\nFor every requested column the function appends Boolean indicator columns â€” one per unique (non-missing) level. New columns are named col_value, e.g. gender_concept_id_8507.\n\nBoolean source columns are detected and skipped automatically with a warning.\n\nArguments\n\nht::HealthTable: Table to transform (schema-aware).\n\nKeyword Arguments\n\ncols::Vector{Symbol}: Categorical columns to encode.\ndrop_original::Bool=true: Drop the source columns after encoding.\nreturn_features_only::Bool=false: If true return a DataFrame containing only the encoded data; if false wrap the result in a HealthTable with disable_type_enforcement=true (because the output is no longer standard OMOP CDM).\n\nReturns\n\nDataFrame or HealthTable depending on return_features_only.\n\nExample\n\nht_ohe = one_hot_encode(ht; cols = [:gender_concept_id, :race_concept_id])\nX = one_hot_encode(ht; cols = [:gender_concept_id], return_features_only = true) # ML features\n\n\n\n\n\n","category":"function"},{"location":"HealthTablePreprocessing/#Vocabulary-Compression","page":"HealthTable: Preprocessing Functions","title":"Vocabulary Compression","text":"","category":"section"},{"location":"HealthTablePreprocessing/","page":"HealthTable: Preprocessing Functions","title":"HealthTable: Preprocessing Functions","text":"Reduce the dimensionality of categorical variables by grouping infrequent levels under a common label.","category":"page"},{"location":"HealthTablePreprocessing/#HealthBase.apply_vocabulary_compression","page":"HealthTable: Preprocessing Functions","title":"HealthBase.apply_vocabulary_compression","text":"apply_vocabulary_compression(ht::HealthTable; cols, min_freq=10, other_label=\"Other\")\n\nGroup infrequent categorical levels under a single other label.\n\nArguments\n\nht::HealthTable: Input data table.\n\nKeyword Arguments\n\ncols::Vector{Symbol}: Columns to compress.\nmin_freq::Int=10: Minimum frequency for a value to remain unchanged.\nother_label::String=\"Other\": Label used to replace infrequent values.\ndrop_original::Bool=false: Whether to drop original columns after compression.\n\nReturns\n\nHealthTable: Table with compressed categorical levels.\n\nExamples\n\nht_small = apply_vocabulary_compression(ht; cols=[:condition_source_value], min_freq=5)\n\n\n\n\n\n","category":"function"},{"location":"HealthTablePreprocessing/#Concept-Translation","page":"HealthTable: Preprocessing Functions","title":"Concept Translation","text":"","category":"section"},{"location":"HealthTablePreprocessing/#Concept-Mapping-(Immutable)","page":"HealthTable: Preprocessing Functions","title":"Concept Mapping (Immutable)","text":"","category":"section"},{"location":"HealthTablePreprocessing/","page":"HealthTable: Preprocessing Functions","title":"HealthTable: Preprocessing Functions","text":"Map OMOP concept IDs to human-readable concept names using the OMOP vocabulary tables, returning a new HealthTable.","category":"page"},{"location":"HealthTablePreprocessing/#HealthBase.map_concepts","page":"HealthTable: Preprocessing Functions","title":"HealthBase.map_concepts","text":"map_concepts(ht::HealthTable, col::Symbol, new_col::String, conn::DuckDB.DB; drop_original::Bool = false, concept_table::String = \"concept\", schema::String = \"main\")\n\nMap concept IDs in a column to their corresponding concept names using the OMOP concept table. Only direct mappings using concept IDs are supported.\n\nArguments\n\nht::HealthTable: Input OMOP data table.\ncols::Union{Symbol, Vector{Symbol}}: Column(s) containing concept IDs.\nconn::DuckDB.DB: Database connection for concept lookup.\n\nKeyword Arguments\n\nnew_cols: Name(s) for output columns. If not provided, uses col * suffix.\nsuffix::String=\"_mapped\": Suffix for default new column names.\ndrop_original::Bool=false: Drop source column(s) after mapping.\nconcept_table::String=\"concept\": Table name for concepts.\nschema::String=\"main\": Schema containing the concept table.\n\nReturns\n\nA new HealthTable with the concept names added in new_col.\n\nExample\n\nconn = DBInterface.connect(DuckDB.DB, \"path/to/db/.duckdb\")\n\n# Map gender_concept_id to concept_name\nht_mapped = map_concepts(ht, :gender_concept_id, \"gender_name\", conn; schema = \"dbt_synthea_dev\")\n\n\n\n\n\n","category":"function"},{"location":"HealthTablePreprocessing/#Concept-Mapping-(In-Place)","page":"HealthTable: Preprocessing Functions","title":"Concept Mapping (In-Place)","text":"","category":"section"},{"location":"HealthTablePreprocessing/","page":"HealthTable: Preprocessing Functions","title":"HealthTable: Preprocessing Functions","text":"In-place version of concept mapping that modifies the original HealthTable directly for memory efficiency.","category":"page"},{"location":"HealthTablePreprocessing/#HealthBase.map_concepts!","page":"HealthTable: Preprocessing Functions","title":"HealthBase.map_concepts!","text":"map_concepts!(ht::HealthTable, cols, conn; ...)\n\nIn-place version of map_concepts. Maps concept IDs to human-readable names using the OMOP concept table.\n\nArguments\n\nht::HealthTable: The table to update.\ncols: Single column or list of columns with concept IDs.\nconn::DuckDB.DB: Connection to the OMOP database.\n\nKeyword Arguments\n\nnew_cols: Optional new column names. Defaults to col * \"_mapped\".\nsuffix: Suffix used when new_cols is not provided.\ndrop_original: Whether to drop the original columns.\nconcept_table, schema: Source table and schema.\n\nReturns\n\nThe mutated HealthTable.\n\nExample\n\nconn = DBInterface.connect(DuckDB.DB, \"path/to/db/.duckdb\")\n\n# Map gender_concept_id to concept_name in-place\nmap_concepts!(ht, :gender_concept_id, conn; new_cols=\"gender_name\", schema=\"dbt_synthea_dev\")\n\n\n\n\n\n","category":"function"},{"location":"#HealthBase.jl","page":"Home","title":"HealthBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Common namespace for functions and interfaces in the JuliaHealth ecosystem","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HealthBase.jl is a foundational package for interacting with the JuliaHealth ecosystem. It is designed to live within your global Julia environment.  The package supports a number of workflows and provides helper functions for JuliaHealth users.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some notable features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Extensible and consistent ecosystem interfaces\nTemplates for common JuliaHealth workflows\nUtilities to quickly build a research study\nInteroperability with packages across Julia community\nLightweight and high code quality","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HealthBase.jl is an interface and foundational level package that acts as a dependency for multiple JuliaHealth packages. It is designed to be as lightweight as possible. As a result, all provided functions that depend on other packages should live in extensions.","category":"page"},{"location":"HealthTableGeneral/#HealthTable:-Tables.jl-Interface-(General)","page":"HealthTable: General Tables.jl Interface","title":"HealthTable: Tables.jl Interface (General)","text":"","category":"section"},{"location":"HealthTableGeneral/#The-HealthTable-Struct","page":"HealthTable: General Tables.jl Interface","title":"The HealthTable Struct","text":"","category":"section"},{"location":"HealthTableGeneral/","page":"HealthTable: General Tables.jl Interface","title":"HealthTable: General Tables.jl Interface","text":"The core of the interface is the HealthTable struct.","category":"page"},{"location":"HealthTableGeneral/#HealthBase.HealthTable","page":"HealthTable: General Tables.jl Interface","title":"HealthBase.HealthTable","text":"HealthTable{T}\n\nA lightweight, schema-aware wrapper for OMOP CDM tables, providing a standardized Tables.jl interface and metadata tracking.\n\nThe HealthTable struct is designed to wrap OMOP CDM-compliant data sources (such as DataFrames), ensuring that all columns  conform to the OMOP CDM specification for a given version. It attaches the OMOP CDM version as metadata and enables seamless  integration with the Julia Tables.jl ecosystem.\n\nFields\n\nsource::T: The underlying data source (typically a DataFrame) containing the OMOP CDM table data.\n\nExamples\n\nperson_df = DataFrame(\n    person_id=1:3,\n    gender_concept_id=[8507, 8532, 8507],\n    year_of_birth=[1990, 1985, 2000]\n)\nht = HealthTable(person_df; omop_cdm_version=\"v5.4.1\")\nTables.schema(ht) # Get the schema\nDataFrame(ht)     # Materialize as DataFrame\n\n\n\n\n\n","category":"type"},{"location":"HealthTableGeneral/#Tables.jl-API-Implementation","page":"HealthTable: General Tables.jl Interface","title":"Tables.jl API Implementation","text":"","category":"section"},{"location":"HealthTableGeneral/","page":"HealthTable: General Tables.jl Interface","title":"HealthTable: General Tables.jl Interface","text":"The HealthTable wrapper types will implement key Tables.jl methods:","category":"page"},{"location":"HealthTableGeneral/","page":"HealthTable: General Tables.jl Interface","title":"HealthTable: General Tables.jl Interface","text":"HealthTable implements the Tables.jl interface to ensure compatibility with the Julia data ecosystem:","category":"page"},{"location":"HealthTableGeneral/#Tables.istable-Tuple{Type{<:HealthTable}}","page":"HealthTable: General Tables.jl Interface","title":"Tables.istable","text":"Tables.istable(::Type{<:HealthTable})\n\nSignal that HealthTable is a table according to the Tables.jl interface.\n\nThis function is part of the Tables.jl interface and is used to identify types that can be treated as tabular data.\n\nReturns\n\nBool: Always returns true for the HealthTable type.\n\n\n\n\n\n","category":"method"},{"location":"HealthTableGeneral/#Tables.rowaccess-Tuple{Type{<:HealthTable}}","page":"HealthTable: General Tables.jl Interface","title":"Tables.rowaccess","text":"Tables.rowaccess(::Type{<:HealthTable})\n\nSignal that HealthTable supports row-based iteration.\n\nThis function is part of the Tables.jl interface. A true return value indicates that Tables.rows can be called on an instance of HealthTable.\n\nReturns\n\nBool: Always returns true for the HealthTable type.\n\n\n\n\n\n","category":"method"},{"location":"HealthTableGeneral/#Tables.rows-Tuple{HealthTable}","page":"HealthTable: General Tables.jl Interface","title":"Tables.rows","text":"Tables.rows(ht::HealthTable)\n\nReturn an iterator over the rows of the HealthTable.\n\nThis function implements the row-access part of the Tables.jl interface by delegating to the underlying source object.\n\nArguments\n\nht::HealthTable: The HealthTable instance.\n\nReturns\n\nAn iterator object that yields each row of the table.\n\n\n\n\n\n","category":"method"},{"location":"HealthTableGeneral/#Tables.columnaccess-Tuple{Type{<:HealthTable}}","page":"HealthTable: General Tables.jl Interface","title":"Tables.columnaccess","text":"Tables.columnaccess(::Type{<:HealthTable})\n\nSignal that HealthTable supports column-based access.\n\nThis function is part of the Tables.jl interface. A true return value indicates that Tables.columns can be called on an instance of HealthTable.\n\nReturns\n\nBool: Always returns true for the HealthTable type.\n\n\n\n\n\n","category":"method"},{"location":"HealthTableGeneral/#Tables.columns-Tuple{HealthTable}","page":"HealthTable: General Tables.jl Interface","title":"Tables.columns","text":"Tables.columns(ht::HealthTable)\n\nReturn the HealthTable's data as a set of columns.\n\nThis function implements the column-access part of the Tables.jl interface by delegating to the underlying source object.\n\nArguments\n\nht::HealthTable: The HealthTable instance.\n\nReturns\n\nA column-accessible object that represents the table's data.\n\n\n\n\n\n","category":"method"},{"location":"HealthTableGeneral/#Tables.schema-Tuple{HealthTable}","page":"HealthTable: General Tables.jl Interface","title":"Tables.schema","text":"Tables.schema(ht::HealthTable)\n\nGet the schema of the HealthTable.\n\nThe schema includes the names and types of the columns. This function delegates the call to the underlying source.\n\nArguments\n\nht::HealthTable: The HealthTable instance.\n\nReturns\n\nTables.Schema: An object describing the column names and their Julia types.\n\n\n\n\n\n","category":"method"},{"location":"HealthTableGeneral/#Tables.materializer-Tuple{Type{<:HealthTable}}","page":"HealthTable: General Tables.jl Interface","title":"Tables.materializer","text":"Tables.materializer(::Type{<:HealthTable})\n\nSpecify the default type to use when materializing a HealthTable.\n\nThis function is part of the Tables.jl interface. It allows other packages to convert a HealthTable into a concrete table type like a DataFrame by calling DataFrame(ht).\n\nReturns\n\nType: The DataFrame type, indicating it as the preferred materialization format.\n\n\n\n\n\n","category":"method"},{"location":"HealthTableGeneral/","page":"HealthTable: General Tables.jl Interface","title":"HealthTable: General Tables.jl Interface","text":"Source: https://tables.juliadata.org/stable/implementing-the-interface/","category":"page"}]
}
